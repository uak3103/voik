// Литература.
// [1] Астрономический ежегодник на 1988 год.
// [2] В.Н.Львов, С.В.Серова. Об одном алгоритме вычисления
// видимых мест звезд с редукциями в прямоугольной системе
// координат.
// [3] Основы эфемеридной астрономии ...


//****************************************************************
// Вычисление матрицы прецесии.
// Параметр: JD - юлианская дата
// Результат: матрица перехода от среднего равноденствия и
// экватора эпохи J2000.0 к среднему равноденствию и экватору
// текущей даты.
// Источник: Астрономический ежегодник на 1988 год, стр.636
//****************************************************************
MATR33 PrecMatr(double JD)
{
  double T=(JD-2451545.0)/36525.0, T2=T*T, T3=T2*T,
	 ksi, z, teta,
	 x, cosx, sinx;
 MATR33  p1, p2, p3;

 ksi = 2306.2181*T+0.30188*T2+0.017998*T3;
 z   = 2306.2181*T+1.09468*T2+0.018203*T3;
 teta= 2004.3109*T-0.42665*T2-0.041833*T3;

 x=-z/3600/180*M_PI; cosx=cos(x); sinx=sin(x);
 p1.m11= cosx; p1.m12= sinx; p1.m13= 0;
 p1.m21=-sinx; p1.m22= cosx; p1.m23= 0;
 p1.m31= 0   ; p1.m32= 0   ; p1.m33= 1;

 x=teta/3600/180*M_PI; cosx=cos(x); sinx=sin(x);
 p2.m11= cosx; p2.m12= 0   ; p2.m13=-sinx;
 p2.m21= 0   ; p2.m22= 1   ; p2.m23= 0;
 p2.m31= sinx; p2.m32= 0   ; p2.m33= cosx;

 x=-ksi/3600/180*M_PI; cosx=cos(x); sinx=sin(x);
 p3.m11= cosx; p3.m12= sinx; p3.m13= 0;
 p3.m21=-sinx; p3.m22= cosx; p3.m23= 0;
 p3.m31= 0   ; p3.m32= 0   ; p3.m33= 1;

 return p1*p2*p3;
}

//****************************************************************
// Параметр: JD - юлианская дата
// Результат: Средний наклон эклиптики к экватору (")
// Источник: Астрономический ежегодник на 1988 год, стр.637
//****************************************************************
double ecliptica ( double JD )
{
 double T=(JD-2451545.0)/36525.0;
 return (84381.448)-46.8150*T-0.00059*T*T+0.001813*T*T*T;
}


//****************************************************************
// Далее следуют таблицы для вычисления параметров нутации
// Источник: Астрономический ежегодник на 1988 год, стр.637-639
//****************************************************************
struct TABLENUT1 {
 signed char k[5];  long ksin; float kTsin; long kcos; float kTcos;
};
struct TABLENUT2 {
 signed char k[5]; signed char ksin, kcos;
};

// Долгопериодическая нутация
TABLENUT1 longnut1[] = {
  {  0, 0, 0, 0, 1,   -171996, -174.2,     92025,    8.9 },
  {  0, 0, 0, 0, 2,      2062,    0.2,      -895,    0.5 },
  { -2, 0, 2, 0, 1,        46,    0.0,       -24,    0.0 },
  {  2, 0,-2, 0, 0,        11,    0.0,         0,    0.0 },
  { -2, 0, 2, 0, 2,        -3,    0.0,         1,    0.0 },
  {  1,-1, 0,-1, 0,        -3,    0.0,         0,    0.0 },
  {  0,-2, 2,-2, 1,        -2,    0.0,         1,    0.0 },
  {  2, 0,-2, 0, 1,         1,    0.0,         0,    0.0 },
  {  0, 0, 2,-2, 2,    -13187,   -1.6,      5736,   -3.1 },
  {  0, 1, 0, 0, 0,      1426,   -3.4,        54,   -0.1 },
  {  0, 1, 2,-2, 2,      -517,    1.2,       224,   -0.6 },
  {  0,-1, 2,-2, 2,       217,   -0.5,       -95,    0.3 },
  {  0, 0, 2,-2, 1,       129,    0.1,       -70,    0.0 },
  {  2, 0, 0,-2, 0,        48,    0.0,         1,    0.0 },
  {  0, 0, 2,-2, 0,       -22,    0.0,         0,    0.0 },
  {  0, 2, 0, 0, 0,        17,   -0.1,         0,    0.0 },
  {  0, 1, 0, 0, 1,       -15,    0.0,         9,    0.0 },
  {  0, 2, 2,-2, 2,       -16,    0.1,         7,    0.0 }
};
TABLENUT2 longnut2[]= {
  {  0,-1, 0, 0, 1,       -12,                 6         },
  { -2, 0, 0, 2, 1,        -6,                 3         },
  {  0,-1, 2,-2, 1,        -5,                 3         },
  {  2, 0, 0,-2, 1,         4,                -2         },
  {  0, 1, 2,-2, 1,         4,                -2         },
  {  1, 0, 0,-1, 0,        -4,                 0         },
  {  2, 1, 0,-2, 0,         1,                 0         },
  {  0, 0,-2, 2, 1,         1,                 0         },
  {  0, 1,-2, 2, 0,        -1,                 0         },
  {  0, 1, 0, 0, 2,         1,                 0         },
  { -1, 0, 0, 1, 1,         1,                 0         },
  {  0, 1, 2,-2, 0,        -1,                 0         }
};

// Короткопериодическая нутация
TABLENUT1 shortnut1[] = {
  {  0, 0, 2, 0, 2,     -2274,   -0.2,       977,   -0.5 },
  {  1, 0, 0, 0, 0,       712,    0.1,        -7,    0.0 },
  {  0, 0, 2, 0, 1,      -386,   -0.4,       200,    0.0 },
  {  1, 0, 2, 0, 2,      -301,    0.0,       129,   -0.1 },
  {  1, 0, 0,-2, 0,      -158,    0.0,        -1,    0.0 },
  { -1, 0, 2, 0, 2,       123,    0.0,       -53,    0.0 },
  {  0, 0, 0, 2, 0,        63,    0.0,        -2,    0.0 },
  {  1, 0, 0, 0, 1,        63,    0.1,       -33,    0.0 },
  { -1, 0, 0, 0, 1,       -58,   -0.1,        32,    0.0 }
};
TABLENUT2 shortnut2[]= {
  { -1, 0, 2, 2, 2,       -59,                26         },
  {  1, 0, 2, 0, 1,       -51,                27         },
  {  0, 0, 2, 2, 2,       -38,                16         },
  {  2, 0, 0, 0, 0,        29,                -1         },
  {  1, 0, 2,-2, 2,        29,               -12         },
  {  2, 0, 2, 0, 2,       -31,                13         },
  {  0, 0, 2, 0, 0,        26,                -1         },
  { -1, 0, 2, 0, 1,        21,               -10         },
  { -1, 0, 0, 2, 1,        16,                -8         },
  {  1, 0, 0,-2, 1,       -13,                 7         },
  { -1, 0, 2, 2, 1,       -10,                 5         },
  {  1, 1, 0,-2, 0,        -7,                 0         },
  {  0, 1, 2, 0, 2,         7,                -3         },
  {  0,-1, 2, 0, 2,        -7,                 3         },
  {  1, 0, 2, 2, 2,        -8,                 3         },
  {  1, 0, 0, 2, 0,         6,                 0         },
  {  2, 0, 2,-2, 2,         6,                -3         },
  {  0, 0, 0, 2, 1,        -6,                 3         },
  {  0, 0, 2, 2, 1,        -7,                 3         },
  {  1, 0, 2,-2, 1,         6,                -3         },
  {  0, 0, 0,-2, 1,        -5,                 3         },
  {  1,-1, 0, 0, 0,         5,                 0         },
  {  2, 0, 2, 0, 1,        -5,                 3         },
  {  0, 1, 0,-2, 0,        -4,                 0         },
  {  1, 0,-2, 0, 0,         4,                 0         },
  {  0, 0, 0, 1, 0,        -4,                 0         },
  {  1, 1, 0, 0, 0,        -3,                 0         },
  {  1, 0, 2, 0, 0,         3,                 0         },
  {  1,-1, 2, 0, 2,        -3,                 1         },
  { -1,-1, 2, 2, 2,        -3,                 1         },
  { -2, 0, 0, 0, 1,        -2,                 1         },
  {  3, 0, 2, 0, 2,        -3,                 1         },
  {  0,-1, 2, 2, 2,        -3,                 1         },
  {  1, 1, 2, 0, 2,         2,                -1         },
  { -1, 0, 2,-2, 1,        -2,                 1         },
  {  2, 0, 0, 0, 1,         2,                -1         },
  {  1, 0, 0, 0, 2,        -2,                 1         },
  {  3, 0, 0, 0, 0,         2,                 0         },
  {  0, 0, 2, 1, 2,         2,                -1         },
  { -1, 0, 0, 0, 2,         1,                -1         },
  {  1, 0, 0,-4, 0,        -1,                 0         },
  { -2, 0, 2, 2, 2,         1,                -1         },
  { -1, 0, 2, 4, 2,        -2,                 1         },
  {  2, 0, 0,-4, 0,        -1,                 0         },
  {  1, 1, 2,-2, 2,         1,                -1         },
  {  1, 0, 2, 2, 1,        -1,                 1         },
  { -2, 0, 2, 4, 2,        -1,                 1         },
  { -1, 0, 4, 0, 2,         1,                 0         },
  {  1,-1, 0,-2, 0,         1,                 0         },
  {  2, 0, 2,-2, 1,         1,                -1         },
  {  2, 0, 2, 2, 2,        -1,                 0         },
  {  1, 0, 0, 2, 1,        -1,                 0         },
  {  0, 0, 4,-2, 2,         1,                 0         },
  {  3, 0, 2,-2, 2,         1,                 0         },
  {  1, 0, 2,-2, 0,        -1,                 0         },
  {  0, 1, 2, 0, 1,         1,                 0         },
  { -1,-1, 0, 2, 1,         1,                 0         },
  {  0, 0,-2, 0, 1,        -1,                 0         },
  {  0, 0, 2,-1, 2,        -1,                 0         },
  {  0, 1, 0, 2, 0,        -1,                 0         },
  {  1, 0,-2,-2, 0,        -1,                 0         },
  {  0,-1, 2, 0, 1,        -1,                 0         },
  {  1, 1, 0,-2, 1,        -1,                 0         },
  {  1, 0,-2, 2, 0,        -1,                 0         },
  {  2, 0, 0, 2, 0,         1,                 0         },
  {  0, 0, 2, 4, 2,        -1,                 0         },
  {  0, 1, 0, 1, 0,         1,                 0         }
};

// Вспомогательная процедура суммирования для процедуры Nut
void sumnut(double *farg, double T,
	    TABLENUT1 *t1, int sz1, TABLENUT2 *t2, int sz2,
	    double &sumsin, double &sumcos)
{
  int i,j; double arg;
  sumsin=0; sumcos=0;
  for(i=0;i<sz1;i++) {
    TABLENUT1 *t=&t1[i];
    arg=0; for(j=0;j<5;j++) arg+=t->k[j]*farg[j];
    arg=arg/3600/180*M_PI;
    sumsin+=(t->ksin+T*t->kTsin)*sin(arg);
    sumcos+=(t->kcos+T*t->kTcos)*cos(arg);
  }
  for(i=0;i<sz2;i++) {
    TABLENUT2 *t=&t2[i];
    arg=0; for(j=0;j<5;j++) arg+=t->k[j]*farg[j];
    arg=arg/3600/180*M_PI;
    sumsin+=(t->ksin)*sin(arg);
    sumcos+=(t->kcos)*cos(arg);
  }
  sumsin/=10000; sumcos/=10000;
}

//****************************************************************
// Вычисление параметров нутации.
// Вх.параметр: JD - юлианская дата
// Вых.параметры:
// deltapsi - долгопериодическая часть нутации по долготе (")
// deltaeps - долгопериодическая часть нутации наклона    (")
// dpsi -   короткопериодическая часть нутации по долготе (")
// deps -   короткопериодическая часть нутации наклона    (")
// Источник: Астрономический ежегодник на 1988 год, стр.637-639
//****************************************************************
void Nut(double JD, double &deltapsi, double &deltaeps,
		       double &dpsi    , double &deps )
{
  double T=(JD-2451545.0)/36525.0, T2=T*T, T3=T2*T;
  double farg[5];
#define R (360*3600L)
  farg[0]= 485866.733+(1325*R+ 715922.633)*T+31.310*T2+0.064*T3;
  farg[1]=1287099.804+(  99*R+1292581.224)*T- 0.577*T2-0.012*T3;
  farg[2]= 335778.877+(1342*R+ 295263.137)*T-13.257*T2+0.011*T3;
  farg[3]=1072261.307+(1236*R+1105601.328)*T- 6.891*T2+0.019*T3;
  farg[4]= 450160.280-(   5*R+ 482890.539)*T+ 7.455*T2+0.008*T3;
#undef R

  sumnut(farg,T,
	 longnut1,sizeof(longnut1)/sizeof(longnut1[0]),
	 longnut2,sizeof(longnut2)/sizeof(longnut2[0]),
	 deltapsi,deltaeps);
  sumnut(farg,T,
	 shortnut1,sizeof(shortnut1)/sizeof(shortnut1[0]),
	 shortnut2,sizeof(shortnut2)/sizeof(shortnut2[0]),
	 dpsi,deps);

}

//****************************************************************
// Вычисление матрицы нутации.
// Вх.параметры: eps0 - средний наклон эклиптики к экватору ("),
//               deltapsi - нутация по долготе ("),
//               deltaeps - нутация наклона    (")
// Результат: матрица перехода от среднего равноденствия и
// экватора к истинному равноденствию и экватору.
// Источник: Астрономический ежегодник на 1988 год, стр.636
//****************************************************************
MATR33 NutMatr (double eps0, double deltapsi, double deltaeps)
{
 double x, cosx, sinx;
 MATR33  p1, p2, p3;

 x=(-eps0-deltaeps)/3600/180*M_PI; cosx=cos(x); sinx=sin(x);
 p1.m11= 1;     p1.m12= 0;    p1.m13= 0;
 p1.m21= 0;     p1.m22= cosx; p1.m23= sinx;
 p1.m31= 0;     p1.m32=-sinx; p1.m33= cosx;

 x=-deltapsi/3600/180*M_PI; cosx=cos(x); sinx=sin(x);
 p2.m11= cosx;  p2.m12= sinx; p2.m13= 0;
 p2.m21=-sinx;  p2.m22= cosx; p2.m23= 0;
 p2.m31= 0;     p2.m32= 0;    p2.m33= 1;

 x=eps0/3600/180*M_PI; cosx=cos(x); sinx=sin(x);
 p3.m11= 1;     p3.m12= 0;    p3.m13= 0;
 p3.m21= 0;     p3.m22= cosx; p3.m23= sinx;
 p3.m31= 0;     p3.m32=-sinx; p3.m33= cosx;

 return p1*p2*p3;
}


//****************************************************************
// Далее следуют данные, используемые в процедуре RedvelCD.
// Источник: [2], стр.28-29.
//****************************************************************
float  C1[] =  { -18.7974,  -0.3149,   -0.0076,   -0.0018,   0     ,
		   0.3150,  -0.0078,   -0.0059,   -0.0018,   0.0007,
		  -0.0004,  -0.0004,    0.0003,    0.0003,  -0.0003,
		  -0.0002,   0.0002,   -0.0002,    0.0002,   0.0002,
		   0.0002,  -0.0002,   -0.0002,   -0.0001,   0.0001,
		   0.0001,  -0.0001,   -0.0001,   -0.0001,  -0.0001,
		  -0.0001,   0.0001,   -0.0001,   -0.0001,  -0.0001,
		   0.0001,  -0.0001,   -0.0001,    0.0001,   0.0001,
		   0.0001,  -0.0001,    0.0001,   -0.0001,   0.0001,
		   0.0001,  -0.0001,   -0.0001,   -0.0001,  -0.0001,
		   0.0001,  -0.0001 };

float  D1[] =  {  -20.4901,  -0.3432,   -0.0084,   -0.0019,   0     ,
		    0.3433,  -0.0085,   -0.0065,   -0.0019,  -0.0007,
		   -0.0005,  -0.0004,    0     ,    0.0004,  -0.0003,
		   -0.0003,   0.0003,   -0.0003,    0.0002,   0.0002,
		   -0.0002,  -0.0002,   -0.0002,   -0.0001,   0.0001,
		    0.0001,  -0.0001,   -0.0001,   -0.0001,  -0.0001,
		   -0.0001,   0.0001,   -0.0001,   -0.0001,  -0.0001,
		    0.0001,  -0.0001,   -0.0001,   -0.0001,   0.0001,
		    0.0001,  -0.0001,    0.0001,   -0.0001,   0.0001,
		    0.0001,  -0.0001,   -0.0001,   -0.0001,   0.0001,
		   -0.0001,  -0.0001 };

float  C11[] = { -0.00187, 0.00076, 0.00005, -0.00021, 0.00006, -0.00076 };

float  D11[] = {  0      , 0.00086, 0.00006, -0.00023, 0.00006, -0.00086 };

float  ARG1[] = { 0.7769352, 0.7727014, 0.625778, 0.875778, 0.487778,
		  0.781169 , 0.751206 , 0.768468, 0.737778, 0.214597,
		  0.573719 , 0.251556 , 0.031252, 0.396924, 0.877235,
		  0.371308 , 0.018315 , 0.535556, 0.215681, 0.201158,
		  0.963042 , 0.268315 , 0.785556, 0.621308, 0.402713,
		  0.965681 , 0.699748 , 0.764234, 0.354808, 0.104808,
		  0.151157 , 0.516912 , 0.225556, 0.219914, 0.243023,
		  0.182563 , 0.969914 , 0.501556, 0.661810, 0.247257,
		  0.806619 , 0.833956 , 0.521146, 0.814287, 0.583956,
		  0.553086 , 0.000785 , 0.803086, 0.250785, 0.197336,
		  0.411810 , 0.432563 };

float  ARG3[] = { 0.0021359, 0.9994963, 0.429397, 0.429397, 0.393872,
		  0.0047755, 0.855231 , 0.996857, 0.393872, 0.992585,
		  0.407590 , 0.858794 , 0.227848, 0.570099, 0.009062,
		  0.553367 , 0.057325 , 0.946947, 0.104598, 0.189942,
		  0.133790 , 0.057325 , 0.946947, 0.553367, 0.431533,
		  0.104598 , 0.561421 , 0.994217, 0.606836, 0.606836,
		  0.572739 , 0.138062 , 0.787744, 0.107238, 0.663651,
		  0.450905 , 0.107238 , 0.858794, 0.100327, 0.666291,
		  0.337981 , 0.897034 , 0.140702, 0.658469, 0.897034,
		  0.412638 , 0.591634 , 0.412638, 0.591634, 0.850959,
		  0.100327 , 0.450905 };

int    IARG2[] = { 100, 199, 8, 8, 3, 0, 1336, 299, 3, 99, 2662, 16, 1342,
		   191, 2485, 162, 100, 99, 225, 1, 83, 100, 99, 162, 108,
		   225, 3810, 399, 0, 0, 91, 283, 6, 125, 193, 37, 125, 16,
		   25, 93, 106, 74, 183, 187, 74, 100, 99, 100, 99, 1136,
		   25, 37 };

//****************************************************************
// Процедура вычисления редукционных величин C и D, необходимых
// для учета годичной аберрации.
// Вх.параметр: JD - юлианская дата
// Вых.параметры: C,D - редукционные величины C и D ("),
// отнесенные к равноденствию и экватору даты.
// Источник: [2].
// Комментарий. Переведено с Фортрана, процедура TAABER, текст:
// стр.28-30, комментарий:стр.16; Управляющий параметр L процедуры
// TAABER полагается равным 0; C и D дополнительно умножены на
// 0.9999863 для перехода к системе постоянных МАС 1976г.
//****************************************************************
void RedvelCD ( double JD , double &C, double &D)
{
  double T=(JD-2415020.0)/36525.0, PA=0.9999863,
	 X, Y, Z, ARG, SA, CA, SA1, CA1;
  int I;

  C=0; D=0;

  for (I=4;I>=0;I--) {
    X=C1[I]+C11[I]*T; Y=D1[I]+D11[I]*T; Z=IARG2[I]*T; Z=Z-(long)Z;
    ARG=(ARG1[I]+Z+ARG3[I]*T)*2*M_PI;
    SA=sin(ARG); CA=cos(ARG); C+=X*CA; D+=Y*SA;
  }

  SA1=0.5284469e-5*T*T; CA1=-0.5*SA1*SA1;
  C+=X*(-SA*SA1+CA*CA1); D+=Y*( CA*SA1+SA*CA1);

  for(I=6;I<=51;I++) {
    X=C1[I]; Y=D1[I]; Z=IARG2[I]*T; Z=Z-(long)Z;
    ARG=(ARG1[I]+Z+ARG3[I]*T)*2*M_PI;
    SA=sin(ARG); CA=cos(ARG); C+=X*CA; D+=Y*SA;
  }

  C*=PA; D*=PA;
}

//****************************************************************
// Процедура вычисления вектора годичной аберрации.
// Вх.параметры:
//   JD - юлианская дата,
//   eps - истинный наклон эклиптики к экватору ("),
//   C,D - редукционные величины C и D (").
// Результат: вектор годичной аберрации.
// Источник: [2],стр.9.
// Комментарий. Вектор равен V/c, где V - вектор скорости Земли
// относительно центра масс Солнечной системы, c - скорость света.
// В этой программе вектор представлен в системе координат,
// связанной с равноденствием и экватором текущей даты.
//****************************************************************
VECT3 VectAberr ( double JD, double eps, double C, double D )
{
 VECT3 v;
 double T=(JD-2415020.0)/36525.0;
 v.x=-D/3600/180*M_PI;
 v.y= C/3600/180*M_PI;
 v.z= C/3600/180*M_PI*tan(eps/3600/180*M_PI)
	 -0.406e-8*cos(0.196+8433.466*T);
 return v;
}


double JD_red;
double deltapsi, dpsi, deltaeps, deps, deltapsiRA=0, dpsiRA=0;
double eps0;
double C_red, D_red;
MATR33 NP, NPT;
VECT3 Vaber;

void init_reduction(double JD)
{
 MATR33 P, N;
 JD_red=JD;
 P=PrecMatr(JD);
 eps0=ecliptica(JD);
 Nut(JD,deltapsi,deltaeps,dpsi,deps);
 double coseps=cos(eps0/3600/180*M_PI);
 deltapsiRA=deltapsi*coseps/15;
 dpsiRA=dpsi*coseps/15;
 N=NutMatr(eps0,deltapsi+dpsi,deltaeps+deps);
 NP=N*P;
 NPT=~NP;
 RedvelCD(JD,C_red,D_red);
 Vaber=VectAberr(JD,eps0+deltaeps+deps,C_red,D_red);
}

//****************************************************************
// Вычисление юлианской даты.
// Входные параметры:
//   D - день (может быть дробным)
//   M - месяц (1...12)
//   Y - год (1900...2100)
// Результат: юлианская дата.
// Источник: ?
// Если D - целый, то выдается Ю.Д. на 0h UT (полуцелая).
// Процедура применима в интервале: 1900,Март ... 2100,Февраль
//****************************************************************
double JulianDate(double D, int M, int Y)
{ return 367L*Y-7*(Y+(M+9)/12)/4+(275*M)/9+D+1721013.5; }

//****************************************************************
// Гринвичское истинное звездное время (сек)
// Вх.параметры:
//   JD - юлианская дата,
//   t - время UT (сек от 0h).
// Источник: Астрономический ежегодник на 1988 год, стр.615-618
//****************************************************************
double GZV(double JD, double t)
{
  JD = 0.5+(long)(JD-0.5);
  double T=(JD-2451545.0)/36525.0;
  double s = (6*3600.0+41*60.0+50.54841) + 8640184.812866*T
	     + 0.093104*T*T - 6.2e-6*T*T*T
	   //+ deltapsiRA + dpsiRA //для совместимости с компл.
	     + t*1.0027379093;
  s/=86400; s-=(int)s; if (s<0) s++;
  return s*86400;
}

//****************************************************************
// Расчет поправки за рефракцию
// Входные параметры:
//   Z - зенитное расстояние (рад)
//   davl - атмосферное давление (мм рт.ст)
//   temp - температура воздуха (С°)
// Результат: поправка к зенитному расстоянию (рад)
// Источник: [3]
//****************************************************************
double refraction(double Z, double davl, double temp)
{ return 60.343*tan(Z)*(davl/760)*(273/(temp+273))/3600/180*M_PI; }


//****************************************************************
// Расчет геоцентрических координат станции
// Вх. параметры:
//   fi  - широта места (рад)
//   h   - высота над уровнем моря (км)
//   mzv - местное звездное время (рад)
// Вых. параметры:
//   X,Y,Z - прямоугольные геоцентрические координаты во
//           второй экваториальной системе (км)
// Источник: Бюракан
//****************************************************************
void cksn(double fi, double h, double mzv,
	  double *x, double *y, double *z)
{
#define ekvradz 6378.137
#define fcompr (1./298.257222101 )
  double sinfi,cosfi,pa,sk,g1,g2,f=fcompr;
  sinfi=sin(fi);
  cosfi=cos(fi);
  pa=1-f*(2.-f)*sinfi*sinfi;
  sk=ekvradz/sqrt(pa);
  g1=sk+h;
  g2=(1-f)*(1-f)*sk+h;
  *x=g1*cosfi*cos(mzv);
  *y=g1*cosfi*sin(mzv);
  *z=g2*sinfi;
}
